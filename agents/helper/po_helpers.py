"""
po_helpers.py
--------------
Two helper functions for your LangGraph purchase order flow:

- _insert_purchase_order(eng, *, Product: str, quantity: int, unit_price: float, status: str = "PLACED") -> str
    Inserts a row into procurement.PurchaseOrders via a SQLAlchemy Engine (or Connection) and
    returns the new PO ID (uuid string).

- _generate_po_pdf(*, po_id: str, Product: str, quantity: int, unit_price: float, total_price: float) -> str
    Generates a simple Purchase Order PDF (ReportLab) and returns the file path.
    Falls back to a .txt file if ReportLab is not installed.

Usage:
    from po_helpers import _insert_purchase_order, _generate_po_pdf

    po_id = _insert_purchase_order(engine, Product="APPLE", quantity=10, unit_price=199.99)
    path = _generate_po_pdf(po_id=po_id, Product="APPLE", quantity=10, unit_price=199.99, total_price=1999.90)

Notes:
    - The target SQL table is assumed to be: procurement.PurchaseOrders
      Columns: PoId (uniqueidentifier), Product (nvarchar), Quantity (int),
               UnitPrice (decimal), TotalPrice (decimal), Status (varchar),
               (CreatedAt default optional in DB).
    - This module does not decrement inventory; do that separately if needed.
"""

from __future__ import annotations

from typing import Tuple

from pathlib import Path
from datetime import datetime
from uuid import uuid4
import os
import re
import urllib.parse
from langchain_core.messages import AIMessage
import requests
# Optional PDF deps (fallback to .txt if reportlab isn't installed)
try:
    from reportlab.lib.pagesizes import A4
    from reportlab.pdfgen import canvas as pdf_canvas
except Exception:  # pragma: no cover
    A4_pagesize = None
    pdf_canvas = None


def _insert_purchase_order(eng, *, Product: str, quantity: int, unit_price: float, vendor_name: str, vendor_url: str, status: str = "PLACED") -> Tuple[str, str]:
    """
    Insert into procurement.PurchaseOrders and return (po_number, po_id).
    - PoId is a GUID (internal)
    - PoNumber is the human-friendly code like 'PO-000123' (generated by SQL)
    """
    po_id = str(uuid4())
    total_price = float(unit_price) * int(quantity) 
    from sqlalchemy import text
    sql = text("""
        INSERT INTO procurement.PurchaseOrders
            (PoId, Product, Quantity, UnitPrice, TotalPrice, VendorName, VendorUrl, Status)
        OUTPUT inserted.PoNumber, inserted.PoId
        VALUES
            (:po_id, :Product, :quantity, :unit_price, :total_price, :vendor_name, :vendor_url, :status);
    """)

    if hasattr(eng, "begin"):
        with eng.begin() as conn:
            row = conn.execute(sql, {
                "po_id": po_id,
                "Product": Product,
                "quantity": int(quantity),
                "unit_price": float(unit_price),
                "total_price": total_price,
                "vendor_name": vendor_name,
                "vendor_url": vendor_url,   
                "status": status,
            }).first()
    else:
        row = eng.execute(sql, {
            "po_id": po_id,
            "Product": Product,
            "quantity": int(quantity),
            "unit_price": float(unit_price),
            "total_price": total_price,
            "vendor_name": vendor_name,
            "vendor_url": vendor_url,
            "status": status,
        }).first()

    po_number, po_id_db = row[0], row[1]  # OUTPUT columns order
    return po_number, po_id_db


def _generate_po_pdf(*, po_id: str, Product: str, quantity: int, unit_price: float, total_price: float, vendor_name:str, vendor_url:str) -> str:
    """Generate a simple Purchase Order PDF (fallback to .txt) and return the file path.

    If the ReportLab package is not installed, this function writes a .txt file
    with the same information.

    Parameters
    ----------
    po_id : str
        Purchase Order ID (uuid string).
    Product : str
        Product key/name.
    quantity : int
        Quantity purchased.
    unit_price : float
        Unit price.
    total_price : float
        Total price.

    Returns
    -------
    str
        Absolute path to the generated PDF (or .txt fallback).
    """
    out_dir = Path("generated_pos")
    out_dir.mkdir(parents=True, exist_ok=True)
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%SZ")
    
    if pdf_canvas is None or A4 is None:
        # Fallback to .txt if ReportLab is unavailable
        txt_path = out_dir / f"{po_id}.txt"
        txt_path.write_text(
            (
                f"PURCHASE ORDER\n\n"
                f"PO ID: {po_id}\n"
                f"Date: {timestamp}\n"
                f"Item: {Product}\n"
                f"Quantity: {quantity}\n"
                f"Unit Price: £{unit_price:.2f}\n"
                f"Total Price: £{total_price:.2f}\n"
                f"Vendor Name: {vendor_name}\n"
                f"Vendor URL: {vendor_url}\n"
                f"Status: PLACED\n"
            ),

            encoding="utf-8",

        )
        return str(txt_path.resolve())

    # Proper PDF via ReportLab
    pdf_path = out_dir / f"{po_id}.pdf"
    c = pdf_canvas.Canvas(str(pdf_path), pagesize=A4)
    width, height = A4
    y = height - 50

    def line(txt: str) -> None:
        nonlocal y
        c.drawString(50, y, txt)
        y -= 18

    c.setFont("Helvetica-Bold", 16)
    c.drawString(50, y, "PURCHASE ORDER")
    y -= 28
    c.setFont("Helvetica", 11)

    line(f"PO ID: {po_id}")
    line(f"Date: {timestamp}")
    line(f"Item: {Product}")
    line(f"Quantity: {quantity}")
    line(f"Unit Price: £{unit_price:.2f}")
    line(f"Total Price: £{total_price:.2f}")
    line(f"Vendor Name: {vendor_name}")
    line(f"Vendor URL: {vendor_url}")
    line("Status: PLACED")

    c.showPage()
    c.save()
    return str(pdf_path.resolve())

def _best_web_price(product: str, currency: str = "GBP"):
    """Return (price, vendor_name, vendor_url) by querying Tavily; None if not found."""
    api_key = (os.getenv("TAVILY_API_KEY") or "").strip()
    if not api_key:  # don't over-validate format; some keys may not start with 'tvly-'
        return None

    TAVILY_ENDPOINT = "https://api.tavily.com/search"
    headers = {
        "Content-Type": "application/json",
        "Accept": "application/json",
        "Authorization": f"Bearer {api_key}",
    }
    payload = {
        "query": f"buy {product} price {currency}",
        "search_depth": "advanced",
        "max_results": 8,
        "include_answer": False,
        "include_images": False,
        "topic": "general",
    }

    try:
        session = requests.Session()
        session.trust_env = False
        resp = session.post(TAVILY_ENDPOINT, headers=headers, json=payload, timeout=30)
        if resp.status_code != 200:
            return None
        data = resp.json()
    except Exception:
        return None

    results = data.get("results") or []
    # Reuse your price extraction
    from helper.currency_helper import _extract_price_currency
    best = None
    for r in results:
        url = r.get("url") or ""
        title = r.get("title") or ""
        content = r.get("content") or ""
        price, cur = _extract_price_currency(f"{title} {content}", currency_hint=currency)
        if isinstance(price, (int, float)):
            vendor = urllib.parse.urlparse(url).netloc
            best = (float(price), vendor, url)
            break
    return best  # or None


def _normalize_product(name: str) -> str:
    n = re.sub(r"\b(Product|laptop|pc|pcs|computer)s?\b$", "", name.strip(), flags=re.I)
    return n.strip().upper()

def _last_assistant_text(messages) -> str:
    for m in reversed(messages or []):
        if isinstance(m, AIMessage):
            return getattr(m, "content", "") or ""
        if isinstance(m, dict) and m.get("role") == "assistant":
            return m.get("content", "")
    if not messages: return ""
    m = messages[-1]
    return getattr(m, "content", m.get("content", "")) if isinstance(m, dict) else getattr(m, "content", "")

def interrupt_text(obj) -> str:
    if isinstance(obj, list):
        for x in obj:
            if hasattr(x, "value"): return str(x.value)
        return str(obj[0]) if obj else ""
    if hasattr(obj, "value"): return str(obj.value)
    if isinstance(obj, dict) and "value" in obj: return str(obj["value"])
    return str(obj)

__all__ = ["_insert_purchase_order", "_generate_po_pdf", "_best_web_price"]
